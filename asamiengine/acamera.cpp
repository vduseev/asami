#include "acamera.h"#include "acamera_p.h"#include <qdebug.h>ACamera::ACamera( QObject* parent )    : QObject( parent )    , d_ptr( new ACameraPrivate( this ) ){}ACamera::ProjectionType ACamera::projectionType() const{    Q_D( const ACamera );    return d->m_projectionType;}QVector3D ACamera::position() const{    Q_D( const ACamera );    return d->m_position;}void ACamera::setPosition( const QVector3D& position ){    Q_D( ACamera );    d->m_position = position;    d->m_cameraToCenter = d->m_viewCenter - position;    d->m_viewMatrixDirty = true;}void ACamera::setUpVector( const QVector3D& upVector ){    Q_D( ACamera );    d->m_upVector = upVector;    d->m_viewMatrixDirty = true;}QVector3D ACamera::upVector() const{    Q_D( const ACamera );    return d->m_upVector;}void ACamera::setViewCenter( const QVector3D& viewCenter ){    Q_D( ACamera );    d->m_viewCenter = viewCenter;    d->m_cameraToCenter = viewCenter - d->m_position;    d->m_viewMatrixDirty = true;}QVector3D ACamera::viewCenter() const{    Q_D( const ACamera );    return d->m_viewCenter;}QVector3D ACamera::viewVector() const{    Q_D( const ACamera );    return d->m_cameraToCenter;}void ACamera::setOrthographicProjection( float left, float right,                                        float bottom, float top,                                        float nearPlane, float farPlane ){    Q_D( ACamera );    d->m_left = left;    d->m_right = right;    d->m_bottom = bottom;    d->m_top = top;    d->m_nearPlane = nearPlane;    d->m_farPlane = farPlane;    d->m_projectionType = OrthogonalProjection;    d->updateOrthogonalProjection();}void ACamera::setPerspectiveProjection( float fieldOfView, float aspectRatio,                                       float nearPlane, float farPlane ){    Q_D( ACamera );    d->m_fieldOfView = fieldOfView;    d->m_aspectRatio = aspectRatio;    d->m_nearPlane = nearPlane;    d->m_farPlane = farPlane;    d->m_projectionType = PerspectiveProjection;    d->updatePerpectiveProjection();}void ACamera::setNearPlane( const float& nearPlane ){    Q_D( ACamera );    if ( qFuzzyCompare( d->m_nearPlane, nearPlane ) )        return;    d->m_nearPlane = nearPlane;    if ( d->m_projectionType == PerspectiveProjection )        d->updatePerpectiveProjection();}float ACamera::nearPlane() const{    Q_D( const ACamera );    return d->m_nearPlane;}void ACamera::setFarPlane( const float& farPlane ){    Q_D( ACamera );    if ( qFuzzyCompare( d->m_farPlane, farPlane ) )        return;    d->m_farPlane = farPlane;    if ( d->m_projectionType == PerspectiveProjection )        d->updatePerpectiveProjection();}float ACamera::farPlane() const{    Q_D( const ACamera );    return d->m_farPlane;}void ACamera::setFieldOfView( const float& fieldOfView ){    Q_D( ACamera );    if ( qFuzzyCompare( d->m_fieldOfView, fieldOfView ) )        return;    d->m_fieldOfView = fieldOfView;    if ( d->m_projectionType == PerspectiveProjection )        d->updatePerpectiveProjection();}float ACamera::fieldOfView() const{    Q_D( const ACamera );    return d->m_fieldOfView;}void ACamera::setAspectRatio( const float& aspectRatio ){    Q_D( ACamera );    if ( qFuzzyCompare( d->m_aspectRatio, aspectRatio ) )        return;    d->m_aspectRatio = aspectRatio;    if ( d->m_projectionType == PerspectiveProjection )        d->updatePerpectiveProjection();}float ACamera::aspectRatio() const{    Q_D( const ACamera );    return d->m_aspectRatio;}void ACamera::setLeft( const float& left ){    Q_D( ACamera );    if ( qFuzzyCompare( d->m_left, left ) )        return;    d->m_left = left;    if ( d->m_projectionType == OrthogonalProjection )        d->updateOrthogonalProjection();}float ACamera::left() const{    Q_D( const ACamera );    return d->m_left;}void ACamera::setRight( const float& right ){    Q_D( ACamera );    if ( qFuzzyCompare( d->m_right, right ) )        return;    d->m_right = right;    if ( d->m_projectionType == OrthogonalProjection )        d->updateOrthogonalProjection();}float ACamera::right() const{    Q_D( const ACamera );    return d->m_right;}void ACamera::setBottom( const float& bottom ){    Q_D( ACamera );    if ( qFuzzyCompare( d->m_bottom, bottom ) )        return;    d->m_bottom = bottom;    if ( d->m_projectionType == OrthogonalProjection )        d->updateOrthogonalProjection();}float ACamera::bottom() const{    Q_D( const ACamera );    return d->m_bottom;}void ACamera::setTop( const float& top ){    Q_D( ACamera );    if ( qFuzzyCompare( d->m_top, top ) )        return;    d->m_top = top;    if ( d->m_projectionType == OrthogonalProjection )        d->updateOrthogonalProjection();}float ACamera::top() const{    Q_D( const ACamera );    return d->m_top;}void ACamera::setClipSpace(    const float& xMin, const float& xMax,    const float& yMin, const float& yMax,    const float& zMin, const float& zMax ){    Q_D( ACamera );    d->m_xMinClip = xMin;    d->m_xMaxClip = xMax;    d->m_yMinClip = yMin;    d->m_yMaxClip = yMax;    d->m_zMinClip = zMin;    d->m_zMaxClip = zMax;}void ACamera::clip(){    Q_D( ACamera );    // Clip x    if ( d->m_position.x() < d->m_xMinClip )        d->m_position.setX( d->m_xMinClip );    else if ( d->m_position.x() > d->m_xMaxClip )        d->m_position.setX( d->m_xMaxClip );    // Clip y    if ( d->m_position.y() < d->m_yMinClip )        d->m_position.setY( d->m_yMinClip );    else if ( d->m_position.y() > d->m_yMaxClip )        d->m_position.setY( d->m_yMaxClip );    // Clip z    if ( d->m_position.z() < d->m_zMinClip )        d->m_position.setZ( d->m_zMinClip );    else if ( d->m_position.z() > d->m_zMaxClip )        d->m_position.setZ( d->m_zMaxClip );}QMatrix4x4 ACamera::viewMatrix() const{    Q_D( const ACamera );    if ( d->m_viewMatrixDirty )    {        d->m_viewMatrix.setToIdentity();        d->m_viewMatrix.lookAt( d->m_position, d->m_viewCenter, d->m_upVector );        d->m_viewMatrixDirty = false;    }    return d->m_viewMatrix;}QMatrix4x4 ACamera::projectionMatrix() const{    Q_D( const ACamera );    return d->m_projectionMatrix;}QMatrix4x4 ACamera::viewProjectionMatrix() const{    Q_D( const ACamera );    if ( d->m_viewMatrixDirty || d->m_viewProjectionMatrixDirty )    {        d->m_viewProjectionMatrix = d->m_projectionMatrix * viewMatrix();        d->m_viewProjectionMatrixDirty = false;    }    return d->m_viewProjectionMatrix;}void ACamera::translate( const QVector3D& vLocal, CameraTranslationOption option ){    Q_D( ACamera );    // Calculate the amount to move by in world coordinates    QVector3D vWorld;    if ( !qFuzzyIsNull( vLocal.x() ) )    {        // Calculate the vector for the local x axis        QVector3D x = QVector3D::crossProduct( d->m_cameraToCenter, d->m_upVector ).normalized();        vWorld += vLocal.x() * x;    }    if ( !qFuzzyIsNull( vLocal.y() ) )        vWorld += vLocal.y() * d->m_upVector;    if ( !qFuzzyIsNull( vLocal.z() ) )        vWorld += vLocal.z() * d->m_cameraToCenter.normalized();    /*if ( !qFuzzyIsNull( vLocal.z() ) )    {        QVector3D x = QVector3D::crossProduct( d->m_cameraToCenter, d->m_upVector ).normalized();        QVector3D z = QVector3D::crossProduct( d->m_upVector, x ).normalized();        vWorld += vLocal.z() * z;    }*/    // Update the camera position using the calculated world vector    d->m_position += vWorld;    // May be also update the view center coordinates    if ( option == TranslateViewCenter )        d->m_viewCenter += vWorld;    // Refresh the camera -> view center vector    d->m_cameraToCenter = d->m_viewCenter - d->m_position;    // Calculate a new up vector. We do this by:    // 1) Calculate a new local x-direction vector from the cross product of the new    //    camera to view center vector and the old up vector.    // 2) The local x vector is the normal to the plane in which the new up vector    //    must lay. So we can take the cross product of this normal and the new    //    x vector. The new normal vector forms the last part of the orthonormal basis    QVector3D x = QVector3D::crossProduct( d->m_cameraToCenter, d->m_upVector ).normalized();    d->m_upVector = QVector3D::crossProduct( x, d->m_cameraToCenter ).normalized();    d->m_viewMatrixDirty = true;}void ACamera::translateWorld(const QVector3D& vWorld , CameraTranslationOption option ){    Q_D( ACamera );    // Update the camera position using the calculated world vector    d->m_position += vWorld;    // May be also update the view center coordinates    if ( option == TranslateViewCenter )        d->m_viewCenter += vWorld;    // Refresh the camera -> view center vector    d->m_cameraToCenter = d->m_viewCenter - d->m_position;    d->m_viewMatrixDirty = true;}QQuaternion ACamera::tiltRotation( const float& angle ) const{    Q_D( const ACamera );    QVector3D xBasis = QVector3D::crossProduct( d->m_upVector, d->m_cameraToCenter.normalized() ).normalized();    return QQuaternion::fromAxisAndAngle( xBasis, -angle );}QQuaternion ACamera::panRotation( const float& angle ) const{    Q_D( const ACamera );    return QQuaternion::fromAxisAndAngle( d->m_upVector, angle );}QQuaternion ACamera::panRotation( const float& angle, const QVector3D& axis ) const{    return QQuaternion::fromAxisAndAngle( axis, angle );}QQuaternion ACamera::rollRotation( const float& angle ) const{    Q_D( const ACamera );    return QQuaternion::fromAxisAndAngle( d->m_cameraToCenter, -angle );}void ACamera::tilt( const float& angle ){    QQuaternion q = tiltRotation( angle );    rotate( q );}void ACamera::pan( const float& angle ){    QQuaternion q = panRotation( -angle );    rotate( q );}void ACamera::pan( const float& angle, const QVector3D& axis ){    QQuaternion q = panRotation( -angle, axis );    rotate( q );}void ACamera::roll( const float& angle ){    QQuaternion q = rollRotation( -angle );    rotate( q );}void ACamera::tiltAboutViewCenter( const float& angle ){    QQuaternion q = tiltRotation( -angle );    rotateAboutViewCenter( q );}void ACamera::panAboutViewCenter( const float& angle ){    QQuaternion q = panRotation( angle );    rotateAboutViewCenter( q );}void ACamera::rollAboutViewCenter( const float& angle ){    QQuaternion q = rollRotation( angle );    rotateAboutViewCenter( q );}void ACamera::rotate( const QQuaternion& q ){    Q_D( ACamera );    d->m_upVector = q.rotatedVector( d->m_upVector );    d->m_cameraToCenter = q.rotatedVector( d->m_cameraToCenter );    d->m_viewCenter = d->m_position + d->m_cameraToCenter;}void ACamera::rotateAboutViewCenter( const QQuaternion& q ){    Q_D( ACamera );    d->m_upVector = q.rotatedVector( d->m_upVector );    d->m_cameraToCenter = q.rotatedVector( d->m_cameraToCenter );    d->m_position = d->m_viewCenter - d->m_cameraToCenter;}