#include "atexture.h"ATexture::ATexture( TextureType type )    : m_type(type)    , m_textureId( 0 ){    initializeOpenGLFunctions();}ATexture::~ATexture(){}void ATexture::create(){    glGenTextures( 1, &m_textureId );}void ATexture::destroy(){    if ( m_textureId )    {        glDeleteTextures( 1, &m_textureId );        m_textureId = 0;    }}void ATexture::bind(){    glBindTexture( m_type, m_textureId );}void ATexture::release(){    glBindTexture( m_type, 0 );}void ATexture::activeTexture( GLenum texture ){    glActiveTexture( texture );}void ATexture::initializeToEmpty( const QSize& size ){    Q_ASSERT( size.isValid() );    Q_ASSERT( m_type == Texture2D );    setRawData2D( m_type, 0, GL_RGBA, size.width(), size.height(), 0,                  GL_RGBA, GL_UNSIGNED_BYTE, 0 );}void ATexture::setImage( const QImage& image ){    Q_ASSERT( m_type == Texture2D );    QImage glImage = convertToGLFormat( image );    setRawData2D( m_type, 0, GL_RGBA, glImage.width(), glImage.height(), 0,                  GL_RGBA, GL_UNSIGNED_BYTE, glImage.bits() );}void ATexture::setCubeMapImage( GLenum face, const QImage& image ){    Q_ASSERT( m_type == TextureCubeMap );    QImage glImage = convertToGLFormat( image );    setRawData2D( face, 0, GL_RGBA8, glImage.width(), glImage.height(), 0,                  GL_RGBA, GL_UNSIGNED_BYTE, glImage.bits() );}void ATexture::setRawData2D( GLenum target, int mipmapLevel, GLenum internalFormat,                            int width, int height, int borderWidth,                            GLenum format, GLenum type, const void* data ){    glTexImage2D( target, mipmapLevel, internalFormat, width, height,                  borderWidth, format, type, data );}void ATexture::generateMipMaps(){    glGenerateMipmap( m_type );}static inline QRgb qt_gl_convertToGLFormatHelper(QRgb src_pixel, GLenum texture_format){    if (texture_format == GL_BGRA) {        if (QSysInfo::ByteOrder == QSysInfo::BigEndian) {            return ((src_pixel << 24) & 0xff000000)                   | ((src_pixel >> 24) & 0x000000ff)                   | ((src_pixel << 8) & 0x00ff0000)                   | ((src_pixel >> 8) & 0x0000ff00);        } else {            return src_pixel;        }    } else {  // GL_RGBA        if (QSysInfo::ByteOrder == QSysInfo::BigEndian) {            return (src_pixel << 8) | ((src_pixel >> 24) & 0xff);        } else {            return ((src_pixel << 16) & 0xff0000)                   | ((src_pixel >> 16) & 0xff)                   | (src_pixel & 0xff00ff00);        }    }}static void convertToGLFormatHelper(QImage &dst, const QImage &img, GLenum texture_format){    Q_ASSERT(dst.depth() == 32);    Q_ASSERT(img.depth() == 32);    if (dst.size() != img.size()) {        int target_width = dst.width();        int target_height = dst.height();        qreal sx = target_width / qreal(img.width());        qreal sy = target_height / qreal(img.height());        quint32 *dest = (quint32 *) dst.scanLine(0); // NB! avoid detach here        uchar *srcPixels = (uchar *) img.scanLine(img.height() - 1);        int sbpl = img.bytesPerLine();        int dbpl = dst.bytesPerLine();        int ix = int(0x00010000 / sx);        int iy = int(0x00010000 / sy);        quint32 basex = int(0.5 * ix);        quint32 srcy = int(0.5 * iy);        // scale, swizzle and mirror in one loop        while (target_height--) {            const uint *src = (const quint32 *) (srcPixels - (srcy >> 16) * sbpl);            int srcx = basex;            for (int x=0; x<target_width; ++x) {                dest[x] = qt_gl_convertToGLFormatHelper(src[srcx >> 16], texture_format);                srcx += ix;            }            dest = (quint32 *)(((uchar *) dest) + dbpl);            srcy += iy;        }    } else {        const int width = img.width();        const int height = img.height();        const uint *p = (const uint*) img.scanLine(img.height() - 1);        uint *q = (uint*) dst.scanLine(0);        if (texture_format == GL_BGRA) {            if (QSysInfo::ByteOrder == QSysInfo::BigEndian) {                // mirror + swizzle                for (int i=0; i < height; ++i) {                    const uint *end = p + width;                    while (p < end) {                        *q = ((*p << 24) & 0xff000000)                             | ((*p >> 24) & 0x000000ff)                             | ((*p << 8) & 0x00ff0000)                             | ((*p >> 8) & 0x0000ff00);                        p++;                        q++;                    }                    p -= 2 * width;                }            } else {                const uint bytesPerLine = img.bytesPerLine();                for (int i=0; i < height; ++i) {                    memcpy(q, p, bytesPerLine);                    q += width;                    p -= width;                }            }        } else {            if (QSysInfo::ByteOrder == QSysInfo::BigEndian) {                for (int i=0; i < height; ++i) {                    const uint *end = p + width;                    while (p < end) {                        *q = (*p << 8) | ((*p >> 24) & 0xff);                        p++;                        q++;                    }                    p -= 2 * width;                }            } else {                for (int i=0; i < height; ++i) {                    const uint *end = p + width;                    while (p < end) {                        *q = ((*p << 16) & 0xff0000) | ((*p >> 16) & 0xff) | (*p & 0xff00ff00);                        p++;                        q++;                    }                    p -= 2 * width;                }            }        }    }}QImage ATexture::convertToGLFormat(const QImage& img){    QImage res(img.size(), QImage::Format_ARGB32);    convertToGLFormatHelper(res, img.convertToFormat(QImage::Format_ARGB32), GL_RGBA);    return res;}